{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"分组密码.md","slug":"分组密码","date":"2025-05-20T11:34:57.000Z","updated":"2025-05-23T12:39:39.760Z","comments":true,"path":"2025/05/20/分组密码/","permalink":"http://example.com/2025/05/20/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/","excerpt":"","text":"分组密码一.简介在密码学中，分组加密（英语：Block cipher），又称分块加密或块密码，是一种对称密钥算法。它将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。分组加密是极其重要的加密协议组成，其中典型的如AES和3DES作为美国政府核定的标准加密算法，应用领域从电子邮件加密到银行交易转帐，非常广泛。 二.分组密码工作模式1.电本码模式（ECB） 电子密码本模式（EBC）特点：（1）如果明文大于64比特，首先将其分为长为64比特的分组; 若最后一个分组如果不够64比特，则需要填充。 （2）明文加密过程和解密过程分别调用加密算法和解密算法。 （3）密文块可以分别独立解密，无顺序要求。 （4）模式操作简单，主要用于数据随机且较少的报文的加密传递（比如加密密钥）； （5）在相同明文，相同密钥下得出相同密文，重复内容·会在密文中表现出来，受统计分析攻击、分组重放攻击和代换攻击。 （6）各组加密相互独立，可以实现并行处理。 （7）有良好的差错控制，单个密文分组出错只会影响该分组的解密结果。 （8）不需要额外的初始变量。 2.密文分组链接模式（CBC） 密文分组链接模式（CBC）特点：（1）每一次加密都需要前一个密文块参与，明文中微小的改变都会使后续所有密文改变。 （2）无法从密文看出明文的规律。安全性得以提高。目前，CBC是最为常用的工作模式。 （3）改变某一个密文块，只会影响当前和下一个解密出的明文，不会影响后续的解密过程。 （4）由于每次加密都需要前一个密文参与，所以无法并行加密，只能串行加密，加密速度受到限制，解密可以并行进行。 3.密文反馈模式（CFB） 密文反馈模式（CFB）特点：（1）将前一个密文块作为输入进行加密，生成一个密钥流，再与当前明文块进行异或运算得到密文块。 （2）密文分组的错误传播敏感、不适合并行处理的场景、需要保证初始向量的唯一性和完整性。 （3）密文没有规律，不容易主动攻击（错误传播），分组转变为流模式，可加密小于分组数据，不需要数据填充。 4.输入反馈模式（OFB） 输入反馈模式（OFB）特点：（1）将前一个加密算法的输出作为输入进行加密，生成一个密钥流，再与当前明文块进行异或运算得到密文块。 （2）可变长度的加密操作，实时性，对密文分组的错误不敏感。 （3）传输错误不可恢复，无法提供数据完整性保护，不支持并行加密。 5.计数器模式（CTR） 计数器模式（CTR）特点：（1）并行处理、随机访问、不受错误传播影响。 （2） 适用于并行加密、随机访问和实时加密的场景。 （3）计数器必须唯一、密钥流和明文相关性较弱。 三.DES1.概述美国国家标准局（NBS，National Bureau of Standards）于1973年开始征集联邦数据加密标准，许多公司提交了算法，IBM公司的Lucifer加密系统最终胜出。经过两年多的公开讨论，1977年1月15日NBS决定利用这个算法，并将其更名为数据加密标准（DES，Data Encryption Standards）。 DES是第一个广泛应用于商用数据保密的密码算法，当时确定有效期为5年，随后在1983年、1988年、1993年三次再度授权该算法续用五年，直到1997年开始征集高级加密标准，2000年选定比利时人设计的Rijndael算法作为新标准。 2.原理整体过程·： （1）由64位密钥生成16个48位子密钥ki 。 （2）对64位明文初始化置换IP，分成左右各半，分别为Li和Ri。 （3）在 16 个子密钥控制下按 Feistel密码结构 进行 16 轮迭代 （每轮迭代包括 E扩展、异或、S盒代换、P置换 ）。 （4）交换左右32位得到R16L16,再进行逆初始置换IP-1。 2.1子密钥的产生对于 64 位的密钥，其有效密钥长度为 56位（另外8位用于校验），先经过置换选择1后分成左右各 28 位。然后再经过 16 次的循环左移和置换选择2，产生 16 个 48 位的子密钥。具体如下： 迭代16次得到16个48位的密钥。 2.2初始化置换IP 将明文用二进制位表示，按 64 位为单位进行分组，将 64 位明文根据初始置换表进行位与位的置换，置换后分为左右各半，即L0和R0，各 32 位。 2.3 Feistel密码结构和16轮的轮函数F变换Feistel密码结构： 加密： 解密： 其中，F轮函数是DES的核心，数据处理宽度为 32 位，具体包括E扩展、异或操作、S盒代换、P置换： （1）E置换 按照扩展置换表，对Ri进行E扩展得到E（Ri），由32位扩展到48位。 （2）异或操作 对E（Ri）和ki+1进行异或操作。 （3）S盒代换 经过扩展的48位明文与48位密钥进行异或运算后，再使用8个S盒压缩成32位数据（每个S盒将6位数据压缩为4位输出）。 每个S盒的数据经过如上处理成为32为数据。 再经过如下P盒置换表，一次轮函数操作完成。 进行16轮的轮函数F变换后，交换左右32比特得到R16L16. 2.4逆初始置换IP-1按照逆初始置换表进行置换得到64位的密文，这是DES加密的最后一步。 四.AES1.概述AES算法是当前最流行的对称加密算法，也是一种分组加密算法，分组密码就是把明文分为固定长度的一组一组，每次加密一组数据，直到加密完整个明文数据。AES算法根据分组长度可以分为AES128, AES192，AES256，其所要求的秘钥长度和加密轮数也各不相同。密钥长度大小只影响加密轮数，不影响加密原理，本文以128位为例。 2.原理整体过程： 以128位密钥为例子，AES算法会对明文先进行【初始变换】（这里的初始变换不属于10轮加密的范畴内），然后是9轮【循环运算】，加1轮【最终轮】，最终得到密文（这里的最终轮其实唯一的区别就是最终轮少了9轮主循环中第3步的列混合） 2.1轮密钥矩阵9轮循环运算和最终论中，每进行一轮，需要对密钥拓展出如下图的wi列，并使（w1, w2, w3, wi）成为当前轮的轮密钥矩阵。 w0 w1 w2 w3 wi 扩展时，规律如下： 1.如果i不是4的倍数，那么第i列由如下等式确定：**w[i]&#x3D;w[i-4] ^ w[i-1]**，例如i等于5时：w[5]&#x3D;w[1] ^ w[4]，即第2列和第5列异或（第1轮没有第5列，第2轮才有第5列）。 2.如果i是4的倍数，那么第i列由如下等式确定：w[i]&#x3D;w[i-4]^T(w[i-1])，例如i等于4时，w[4]&#x3D;w[0] ^ T(w[3])，即第1列和经过T函数计算的第4列异或。 函数T由3部分组成：字循环、字节代换和轮常量异或。 （1）字循环 （2）字节代换 将字节映射到进行的S-BOX中进行字节替换 （3）轮常量异或 轮常量是给定的，将前两步的结果与对应的轮常量进行异或得到。 2.2初始变换无论是明文还是密钥，16个字节（即128位）的字符，在进行加密的过程中都是以4*4的矩阵形式存在的，这个矩阵也有要求——输入的字符需要按从上到下从左往右的顺序排列成矩阵。 AES的初始变换操作，就是对明文矩阵和密钥矩阵对应的元素异或得到新矩阵，如下图 2.3 9轮循环运算（1）字节代换对经过初始变换的矩阵中的每一个元素替换掉，按照矩阵元素的值去映射S-BOX中对应的值 （2）行移位矩阵的第一行不变，第二行向左移动1个字节，第三行向左移动2个字节，第四行向左移动3个字节 （3）列混合（不在最终行执行）左乘一个给定的4*4矩阵，这个矩阵是程序设计时给定的，可能每个程序使用的AES算法中的这个矩阵不一定相同。 列混合的矩阵相乘与正常的不同（相加的加号换为了异或） 并且乘法也要通过运算替换为异或进行计算（S（0，0）&#x3D;(a7,a6,a5,a4,a3,a2,a1,a0)） （4）轮密钥加对完成列混合的矩阵和轮密钥矩阵对应的元素进行异或。 五.例题1.DESbuuctf[ACTF新生赛2020]crypto-deshttps://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]crypto-des 下载文件后解压后打开，发现有两个附件和一个压缩包（压缩包需要密码，且爆破不出来） 感觉应该像是浮点数的二进制表示，分别用大端序与小端序解码下： from libnum import* import struct import binascii s = [72143238992041641000000.000000,77135357178006504000000000000000.000000,1125868345616435400000000.000000,67378029765916820000000.000000,75553486092184703000000000000.000000,4397611913739958700000.000000,76209378028621039000000000000000.000000] a = &#39;&#39; b = &#39;&#39; for i in s: i = float(i) a += struct.pack(&#39;&lt;f&#39;,i).hex() #小端 print(a) for j in s: i = float(j) b += struct.pack(&#39;&gt;f&#39;,i).hex() #大端 print(b) a = 0x496e74657265737472696e67204964656120746f20656e6372797074 b = 0x74707972747079727470797274707972747079727470797274707972 print(n2s(a)) print(n2s(b)) 小端序输出为Interestring Idea to encrypt 大端序输出为tpyrtpyrtpyrtpyrtpyrtpyrtpyr 小端序的输出更像是压缩包密码，输入密码后，解压出一个python文件 import pyDesimport base64from FLAG import flagdeskey = &quot;********&quot;DES = pyDes.des(deskey)DES.setMode(&#39;ECB&#39;)DES.Kn = [ [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1] ]cipher_list = base64.b64encode(DES.encrypt(flag))#b&#39;vrkgBqeK7+h7mPyWujP8r5FqH5yyVlqv0CXudqoNHVAVdNO8ML4lM4zgez7weQXo&#39; 上述代码给出了密钥跟16轮子密钥，可以构建解密代码 import pyDesimport base64from Crypto.Util.number import*deskey = &quot;********&quot;DES = pyDes.des(deskey)DES.setMode(&#39;ECB&#39;)DES.Kn = [ [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1] ] k = b&#39;vrkgBqeK7+h7mPyWujP8r5FqH5yyVlqv0CXudqoNHVAVdNO8ML4lM4zgez7weQXo&#39;data = base64.b64decode(k) flag = DES.decrypt(data) print(flag) 解码后得到flag：actf{breaking_DES_is_just_a_small_piece_of_cake}，将actf改为flag即可。 2.AESbuuctf[Dest0g3 520迎新赛]babyAEShttps://buuoj.cn/challenges#[Dest0g3%20520%E8%BF%8E%E6%96%B0%E8%B5%9B]babyAES 下载后是一个python文件 from Crypto.Cipher import AES import os iv = os.urandom(16) key = os.urandom(16) my_aes = AES.new(key, AES.MODE_CBC, iv) flag = open(&#39;flag.txt&#39;, &#39;rb&#39;).read() flag += (16 - len(flag) % 16) * b&#39;\\x00&#39; c = my_aes.encrypt(flag) print(c) print(iv) print(key) &#39;&#39;&#39; b&#39;C4:\\x86Q$\\xb0\\xd1\\x1b\\xa9L\\x00\\xad\\xa3\\xff\\x96 hJ\\x1b~\\x1c\\xd1y\\x87A\\xfe0\\xe2\\xfb\\xc7\\xb7\\x7f^\\xc8\\x9aP\\xdaX\\xc6\\xdf\\x17l=K\\x95\\xd07&#39; b&#39;\\xd1\\xdf\\x8f)\\x08w\\xde\\xf9yX%\\xca[\\xcb\\x18\\x80&#39; b&#39;\\xa4\\xa6M\\xab&#123;\\xf6\\x97\\x94&gt;hK\\x9bBe]F&#39; &#39;&#39;&#39; 上述代码给定了密钥，初始化变量还有密文，可以构建解密代码 from Crypto.Cipher import AESimport os iv = b&#39;\\xd1\\xdf\\x8f)\\x08w\\xde\\xf9yX%\\xca[\\xcb\\x18\\x80&#39;key = b&#39;\\xa4\\xa6M\\xab&#123;\\xf6\\x97\\x94&gt;hK\\x9bBe]F&#39;my_aes = AES.new(key, AES.MODE_CBC, iv)flag = b&#39;C4:\\x86Q$\\xb0\\xd1\\x1b\\xa9L\\x00\\xad\\xa3\\xff\\x96 hJ\\x1b~\\x1c\\xd1y\\x87A\\xfe0\\xe2\\xfb\\xc7\\xb7\\x7f^\\xc8\\x9aP\\xdaX\\xc6\\xdf\\x17l=K\\x95\\xd07&#39;c = my_aes.decrypt(flag)print(c) b&#39;Dest0g3&#123;d0e5fa76-e50f-76f6-9cf1-b6c2d576b6f4&#125;\\x00\\x00\\x00&#39; 解密得flag：Dest0g3{d0e5fa76-e50f-76f6-9cf1-b6c2d576b6f4}，开头替换成flag即可。","categories":[],"tags":[]},{"title":"题目分享","slug":"题目分享","date":"2025-04-10T10:48:58.000Z","updated":"2025-04-11T09:04:01.869Z","comments":true,"path":"2025/04/10/题目分享/","permalink":"http://example.com/2025/04/10/%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","excerpt":"","text":"BUUCTF[2019红帽杯]easyRE一.打开题目进行下载查壳 文件是elf文件，下载之后拖入ExeinfoPE中进行查壳 发现是64位文件，无壳 二.将文件拖入到64位IDA中进行进一步分析进入IDA中发现该文件找不到main函数，那就shift+F12打开string窗口跟踪一下存储的字符串常量 在第一行发现一串可疑字符串点开 观察这一串长字符串应该是base加密后的产物 Vm0wd2VHUXhTWGhpUm1SWVYwZDRWVll3Wkc5WFJsbDNXa1pPVlUxV2NIcFhhMk0xVmpKS1NHVkdXbFpOYmtKVVZtcEtTMUl5VGtsaVJtUk9ZV3hhZVZadGVHdFRNVTVYVW01T2FGSnRVbGhhVjNoaFZWWmtWMXBFVWxSTmJFcElWbTAxVDJGV1NuTlhia0pXWWxob1dGUnJXbXRXTVZaeVdrWm9hVlpyV1hwV1IzaGhXVmRHVjFOdVVsWmlhMHBZV1ZSR1lWZEdVbFZTYlhSWFRWWndNRlZ0TVc5VWJGcFZWbXR3VjJKSFVYZFdha1pXWlZaT2NtRkhhRk5pVjJoWVYxZDBhMVV3TlhOalJscFlZbGhTY1ZsclduZGxiR1J5VmxSR1ZXSlZjRWhaTUZKaFZqSktWVkZZYUZkV1JWcFlWV3BHYTFkWFRrZFRiV3hvVFVoQ1dsWXhaRFJpTWtsM1RVaG9hbEpYYUhOVmJUVkRZekZhY1ZKcmRGTk5Wa3A2VjJ0U1ExWlhTbFpqUldoYVRVWndkbFpxUmtwbGJVWklZVVprYUdFeGNHOVhXSEJIWkRGS2RGSnJhR2hTYXpWdlZGVm9RMlJzV25STldHUlZUVlpXTlZadE5VOVdiVXBJVld4c1dtSllUWGhXTUZwell6RmFkRkpzVWxOaVNFSktWa1phVTFFeFduUlRhMlJxVWxad1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ&#x3D;&#x3D; 在网站上经历十次base64解密后得到一个网址：https://bbs.pediy.com/thread-254172.htm 打开发现是一篇文章，而且对于本题没有提示，是一个干扰信息 在可疑字符串的下面有一串英文You found me！！！像是存在关键信息的地方，打开后的位置无法进行反编译出伪C代码，那就用快捷键Ctrl+X查看调用这个字符串的地方并进入 感觉这个函数应该是主函数，将函数名重名为main；主函数中有一串三串字符串v12，v13,v14， 而且在v12，v13的字符串的最后还加了一个数字127，在Ascii中对应空格，也就是说v12，v13字符串相较于上面的多了一个空格，下面的函数对v15进行了处理；先进行了对于v15长度的判断，v15的长度是36；然后进入了（0，35）的循环v15[i]^i&#x3D;&#x3D;v12[i] (v12字符串循环后用下面的v13,v14的字符串) 那么将v12,v13,v14的字符串连起来进行(0,35)的循环分别与i进行异或就能得到字符串v15 以下为python代码： 1234567v = &quot;Iodl&gt;Qnb(ocy y.i d`3w&#125;wek9&#123;iy=~yL@EC&quot;v15 = &quot;&quot;for i in range(len(v)): v15 += chr(ord(v[i]) ^ i)print(v15) 输出结果如上，大概应该是说”flag”字符在后面应该会用得上 继续向下分析代码 sub_400E44这个函数进行了10次，点开分析后发现是base64编码，应该就是之前的十次base64解密得出网址的干扰信息，继续向下分析 点开off_6CC090 在左边有可疑函数交叉引用后进入函数 进入函数后分析该函数，发现 这段函数中的byte_6CC0A0与byte_6CC0A3对应的数据与v1，v4异或后为”f”,”g”,联想到之前所出现的flag字符；反过来异或一下便能求出这串字符串 接着向下进行分析发现进入了(0,24)的循环当中，从byte_6CC0A0开始的字符与求出的v4字符串进行异或，构建pytho代码 12345678910byte_6CC0A3 = [0x40,0x35,0x20,0x56,0x5D,0x18,0x22,0x45,0x17,0x2F,0x24,0x6E,0x62,0x3C,0x27,0x54,0x48,0x6C,0x24,0x6E,0x72,0x3C,0x32,0x45,0x5B]key = &quot;&quot;flag = &quot;&quot;v15 = &quot;flag&quot;for i in range(4): key+=chr(byte_6CC0A3[i]^ord(v15[i]))print(key)for j in range(len(byte_6CC0A3)): flag+=chr(byte_6CC0A3[j]^ord(key[j%4]))print(flag) 输出结果为：","categories":[],"tags":[]},{"title":"安卓逆向","slug":"安卓逆向","date":"2025-03-30T06:48:28.000Z","updated":"2025-04-11T09:13:36.644Z","comments":true,"path":"2025/03/30/安卓逆向/","permalink":"http://example.com/2025/03/30/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/","excerpt":"","text":"安卓逆向基础apk文件简介APK是Android Package的缩写，即Android安装包。APK是类似Symbian Sis或Sisx的文件格式。通过将APK文件直接传到Android模拟器或Android手机中执行即可安装。 APK文件其实是zip格式，但后缀名被修改为apk，通过UnZip解压后，可以看到Dex文件，Dex是Dalvik VM executes的全称，即Android Dalvik执行程序，并非Java ME的字节码而是Dalvik字节码。 结构组成AndroidManifest.xml 程序全局配置文件，该文件是每个应用程序都必须定义和包含的文件，它描述了应用程序的名字、版本、权限、引用的库文件等等信息。需要解包后才能加以阅读。做题时可以先查找 AndroidManifest.xml 文件里的 Activity 标签，一个Activity相当于一个页面，可以快速找到MainActivity并跳转。 classes.dex文件是Java源码编译后生成的Java字节码文件。 resources.arsc 是编译后的二进制资源文件。 META-INF目录 该目录下存放的是签名信息，用来保证apk包的完整性和系统的安全。在eclipse编译生成一个apk包时，会对所有要打包的文件做一个校验计算，并把计算结果放在META-INF目录下。这就保证了apk包里的文件不能被随意替换。比如拿到一个apk包后，如果想要替换里面的一幅图片，一段代码， 或一段版权信息，想直接解压缩、替换再重新打包，基本是不可能的。如此一来就给病毒感染和恶意修改增加了难度，有助于保护系统的安全。 res目录存放资源文件。包括图片，字符串等等。解包后，几乎所有可能的修改和编辑工作基本都在这里。 assets目录可以存放一些配置文件，这些文件的内容在程序运行过程中可以通过相关的API获得。 lib目录：存放应用依赖的 native 库文件，一般用 C&#x2F;C++ 编写。lib 目录根据 CPU 型号的不同，可能包含四种文件夹：ARM，ARM-v7a，MIPS，X86，分别对应 ARM 架构，ARM-v7a 架构，MIPS 架构和 X86 架构。做题过程中需要的.so文件就在此目录下。 apk文件生成流程 安卓逆向工具一·jadx的安装与使用简介jadx 是一款使用广泛的反编译工具，可以一键把 apk 文件还原成 Java 代码，使用起来很简单，功能强大，还具有一些附加功能可以辅助代码追查。 主要功能：1.除了反编译 apk 文件，还可以反编译 jar、class、dex、aar 等文件和 zip 文件中的 Dalvik 字节码。 2.解码 AndroidManifest.xml 文件和一些来自 resources.arsc 中的资源文件。 3.一些 apk 文件在打包过程中增加了 Java 代码的混淆机制，对比 jadx 提供反混淆的支持。 jadx本身是命令行工具，可以通过命令将apk文件进行反编译。除此之外还有图形化页面工具jadx-gui，拥有搜索，定位等功能。 安装下载链接：https://github.com/skylot/jadx/releases/tag/v1.4.7 如图所示： 使用方法1.打开软件通过文件位置打开或将文件拖入软件中打开 2.文本搜索功能 3.文件导出功能（鼠标右键单击导出文件） 4.跳转到声明方法与查找用例 二·JEB的安装和使用简介JEB 是由 PNF 软件(PNF Software) 机构开发的一款专业的反编译 Android App 的工具，适用于逆向和审计工程，功能非常强大。相比 jadx，JEB 除了支持 apk 文件的反编译和 Android App 的动态调试，还支持 ARM、MIPS、AVR、Inter-x86、WebAssembly、Ethereum(以太坊) 等程序的反编译、反汇编、动态调试等。 安装下载地址：https://bbs.kanxue.com/thread-268316.htm 使用使用方法：进入 JEB 解压后的目录，Windows 下双击 **jeb_wincon.bat**，按照弹窗 generate a license，即可正常使用。 然后将所要分析的apk文件拖入软件框中","categories":[],"tags":[]},{"title":"初学汇编语言","slug":"初学汇编语言","date":"2025-03-19T09:12:06.000Z","updated":"2025-03-21T12:33:30.544Z","comments":true,"path":"2025/03/19/初学汇编语言/","permalink":"http://example.com/2025/03/19/%E5%88%9D%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","excerpt":"","text":"8086汇编8086CPU组成结构1.8086CPU上有14个寄存器，其中有8个通用寄存器，且所有的寄存器都为16位寄存器，只可以存放两个字节 2.CPU是由运算器，控制器和寄存器等器件组成，这些器件之间由内部总线相连接，同时CPU与主板等其它器件则依靠外部总线相连接，有三条总线为地址总线，数据总线，控制总线（地址总线可以传输20位的数据，实际地址&#x3D;段地址*10+偏移地址） 汇编语言的执行1.汇编指令由CPU执行，而伪指令和其它符号则是由编译器负责识别与执行的 2.在8086CPU中数据不能直接放入段寄存器中，需要通过通用寄存器转存进入段寄存器当中 简单的汇编指令1.进栈与出栈（1）进栈push ax：将数据ax送入栈中；与此同时，栈顶的位置也会发生改变（8086CPU中栈顶一直由SS：SP指向（32中由esp指向栈顶），push ax时，第一步SP-2，第·二步将ax中数据放入SS：SP指向的位置） （2）出栈pop ax：从栈顶取出数据放入ax当中；同样栈顶的位置也会随之发生改变（pop ax：第一步，先将栈顶的数据送入ax当中；第二步，SP-2） 2.传输数据与数据运算（1）数据传输mov ax，bx ：将bx中的数据传输到ax当中 （2）数据运算1.add ax，bx ：ax&#x3D;ax+ax 2.sub ax，bx ：ax&#x3D;ax-bx 3.inc ax ：ax&#x3D;ax+1 4.dec ax ：ax&#x3D;ax-1 3.控制转移指令1.loop：循环，用cx进行循环次数的判定，指令分两步执行（1）：将cx中的数据减1；（2）判断cx是否为0，若不为零，则跳转到标号处的命令进行执行，然后继续进行第一步，若cx为0；则循环结束，执行下一步 2.jmp ax ：跳转到偏移地址为ax的地址当中 4.与结束相关的指令1.段结束：ends（伪指令）2.程序结束：end（伪指令）3.程序返回：mov ax,4c00H int 21H （汇编指令）","categories":[],"tags":[]},{"title":"初学密码学","slug":"初学密码学","date":"2024-10-27T08:02:21.000Z","updated":"2024-10-27T08:18:45.403Z","comments":true,"path":"2024/10/27/初学密码学/","permalink":"http://example.com/2024/10/27/%E5%88%9D%E5%AD%A6%E5%AF%86%E7%A0%81%E5%AD%A6/","excerpt":"","text":"#古典密码学 ##一.凯撒密码 它是一种替换加密的技术，明文中的所有字母都在字母表上向后按照一个固定数目进行偏移后被替换成密文。 ##二.维吉尼亚密码 是由一些偏移量不同的恺撒密码组成。为了生成密码，需要使用表格法。这一表格包括了26行字母表，每一行都由前一行向左偏移一位得到。具体使用哪一行字母表进行编译是基于密钥进行的，在过程中会不断地变换。 ##三.培根密码 培根密码的本质是将字母用一串二进制数替换，但是表示的过程中，没有采取0和1的形式，而使用a和b来代替。 ##四.栅栏密码 属于移项密码。","categories":[],"tags":[]},{"title":"这是我的第一篇博客","slug":"这是我的第一篇博客","date":"2024-10-27T03:31:14.000Z","updated":"2024-10-27T07:58:03.639Z","comments":true,"path":"2024/10/27/这是我的第一篇博客/","permalink":"http://example.com/2024/10/27/%E8%BF%99%E6%98%AF%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"#简介 ##一.初入计算机 计算机的一切，对于我这个初学者来说，一切都是那么的神秘，充满了未知。这份神秘，令人畏惧，同时也令人神往。 ##二.略懂计算机 经过一个月的计算机学习，对于计算机有了一定的了解，略微知道了计算机的运行原理。让我对计算机多了一分认识，同时也多了一份向往。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-10-16T06:29:30.119Z","updated":"2024-10-16T06:29:30.119Z","comments":true,"path":"2024/10/16/hello-world/","permalink":"http://example.com/2024/10/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}